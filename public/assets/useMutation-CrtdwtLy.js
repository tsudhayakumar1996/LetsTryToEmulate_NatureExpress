var I=s=>{throw TypeError(s)};var _=(s,t,e)=>t.has(s)||I("Cannot "+e);var r=(s,t,e)=>(_(s,t,"read from private field"),e?e.call(s):t.get(s)),p=(s,t,e)=>t.has(s)?I("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(s):t.set(s,e),m=(s,t,e,o)=>(_(s,t,"write to private field"),o?o.call(s,e):t.set(s,e),e),E=(s,t,e)=>(_(s,t,"access private method"),e);import{r as O}from"./index-D4cGdlsG.js";import{S as G,w as L,q as R,C as F,b as P,A as x,B as D,z as K}from"./utils-wexUoY71.js";const z="/auth/register",B="/auth/passwordReset",Q="/auth/completeRegister",W="/auth/passwordConfirm",X="/auth/me",Y="/auth/login/google",j="GET",k="POST",Z="Login",tt="Register",st="Forgot password",et="Complete register",rt="Confirm password",J="jwtToken",ot=(s,t)=>localStorage.setItem(s,t),U=s=>localStorage.getItem(s),it=()=>localStorage.clear(),v="http://localhost:4001",A=async s=>{const t=await s.json();if(s.ok)return t;throw new Error(t.message)},N=s=>{let t="An unknown error occurred";return s instanceof Error&&(t=s.message),new Error(JSON.stringify({message:t}))},M=()=>({"Content-Type":"application/json",Authorization:`Bearer ${U(J)??""}`}),at=async({endUrl:s})=>{try{const t=await fetch(`${v}${s}`,{method:j,headers:M(),credentials:"include"});return await A(t)}catch(t){throw N(t)}},nt=async({endUrl:s,reqObj:t})=>{try{const e=await fetch(`${v}${s}`,{method:k,headers:M(),body:JSON.stringify(t),credentials:"include"});return await A(e)}catch(e){throw N(e)}};var u,c,i,a,n,f,y,C,$=(C=class extends G{constructor(t,e){super();p(this,n);p(this,u);p(this,c);p(this,i);p(this,a);m(this,u,t),this.setOptions(e),this.bindMethods(),E(this,n,f).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){var o;const e=this.options;this.options=r(this,u).defaultMutationOptions(t),L(this.options,e)||r(this,u).getMutationCache().notify({type:"observerOptionsUpdated",mutation:r(this,i),observer:this}),e!=null&&e.mutationKey&&this.options.mutationKey&&R(e.mutationKey)!==R(this.options.mutationKey)?this.reset():((o=r(this,i))==null?void 0:o.state.status)==="pending"&&r(this,i).setOptions(this.options)}onUnsubscribe(){var t;this.hasListeners()||(t=r(this,i))==null||t.removeObserver(this)}onMutationUpdate(t){E(this,n,f).call(this),E(this,n,y).call(this,t)}getCurrentResult(){return r(this,c)}reset(){var t;(t=r(this,i))==null||t.removeObserver(this),m(this,i,void 0),E(this,n,f).call(this),E(this,n,y).call(this)}mutate(t,e){var o;return m(this,a,e),(o=r(this,i))==null||o.removeObserver(this),m(this,i,r(this,u).getMutationCache().build(r(this,u),this.options)),r(this,i).addObserver(this),r(this,i).execute(t)}},u=new WeakMap,c=new WeakMap,i=new WeakMap,a=new WeakMap,n=new WeakSet,f=function(){var e;const t=((e=r(this,i))==null?void 0:e.state)??F();m(this,c,{...t,isPending:t.status==="pending",isSuccess:t.status==="success",isError:t.status==="error",isIdle:t.status==="idle",mutate:this.mutate,reset:this.reset})},y=function(t){P.batch(()=>{var e,o,h,g,l,S,T,w;if(r(this,a)&&this.hasListeners()){const d=r(this,c).variables,b=r(this,c).context;(t==null?void 0:t.type)==="success"?((o=(e=r(this,a)).onSuccess)==null||o.call(e,t.data,d,b),(g=(h=r(this,a)).onSettled)==null||g.call(h,t.data,null,d,b)):(t==null?void 0:t.type)==="error"&&((S=(l=r(this,a)).onError)==null||S.call(l,t.error,d,b),(w=(T=r(this,a)).onSettled)==null||w.call(T,void 0,t.error,d,b))}this.listeners.forEach(d=>{d(r(this,c))})})},C);function ht(s,t){const e=x(),[o]=O.useState(()=>new $(e,s));O.useEffect(()=>{o.setOptions(s)},[o,s]);const h=O.useSyncExternalStore(O.useCallback(l=>o.subscribe(P.batchCalls(l)),[o]),()=>o.getCurrentResult(),()=>o.getCurrentResult()),g=O.useCallback((l,S)=>{o.mutate(l,S).catch(D)},[o]);if(h.error&&K(o.options.throwOnError,[h.error]))throw h.error;return{...h,mutate:g,mutateAsync:h.mutate}}export{et as C,st as F,Y as G,J,Z as L,rt as P,tt as R,X as a,z as b,B as c,Q as d,W as e,U as f,at as g,nt as p,it as r,ot as s,ht as u};
